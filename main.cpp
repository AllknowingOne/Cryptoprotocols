#include "LSX.hpp"

using namespace cipher;

//using BlockVector = cipher::BlockVector;

//
//template<size_t N, typename T>
//void
//print(const T (&arr)[N]) {
//    for(size_t i{}; i < N; ++i) {
//        std::cout << arr[i] << std::endl;
//    }
//}
//
//template<size_t N>
//void
//print(const uint8_t(&arr)[N]) {
//    for(size_t i{}; i < N; ++i) {
//        std::cout << std::hex << (int)arr[i];
//    }
//    std::cout  << std::endl;
//}

auto
main()
->int {

//    Streebog hash{512};
//    uint8_t key[64] = {};
//    uint8_t salt[72] = {0xfb,0xea,0xfa,0xeb,0xef,0x20,0xff,0xfb,0xf0,0xe1,0xe0,0xf0,0xf5,0x20,0xe0,0xed,0x20,0xe8,0xec,0xe0,0xeb,0xe5,0xf0,0xf2,0xf1,0x20,0xff,0xf0,0xee,0xec,0x20,0xf1,0x20,0xfa,0xf2,0xfe,0xe5,0xe2,0x20,0x2c,0xe8,0xf6,0xf3,0xed,0xe2,0x20,0xe8,0xe6,0xee,0xe1,0xe8,0xf0,0xf2,0xd1,0x20,0x2c,0xe8,0xf0,0xf2,0xe5,0xe2,0x20,0xe5,0xd1};
//
//                       uint8_t msg[72] = {0xfb,0xea,0xfa,0xeb,0xef,0x20,0xff,0xfb,0xf0,0xe1,0xe0,0xf0,0xf5,0x20,0xe0,0xed,0x20,0xe8,0xec,0xe0,0xeb,0xe5,0xf0,0xf2,0xf1,0x20,0xff,0xf0,0xee,0xec,0x20,0xf1,0x20,0xfa,0xf2,0xfe,0xe5,0xe2,0x20,0x2c,0xe8,0xf6,0xf3,0xed,0xe2,0x20,0xe8,0xe6,0xee,0xe1,0xe8,0xf0,0xf2,0xd1,0x20,0x2c,0xe8,0xf0,0xf2,0xe5,0xe2,0x20,0xe5,0xd1,
//                       0x20, 0xc8, 0xe3,0xee, 0xf0, 0xe5, 0xe2,0xfb
//                        };
//
//    for(int i{}; i < 32; ++i) {
//        std::swap(msg[i], msg[63-i]);
//    }
//
//    hash(msg, 72);
//
//    hash.show();
//
//    HMAC hmac;
//
//    uint8_t result[10] = {};
//    uint8_t IV[64] = {};
//    std::string P = "диверсифицированный ключ";
//    std::string U = "username: Kadius Lunarflame";
//
//    kdf2(key, salt, IV, 0, P, U, result);
//    print(result);


    BlockVector key{0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01, 0x10,0x32,0x54,0x76,0x98,0xba, 0xdc, 0xfe, 0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88};
    LSX cipher(key);
    BlockVector state{0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00,0x77,0x66,0x55,0x44,0x33,0x22,0x11};

    cipher.E(std::move(state));
    cipher.show();

    BlockVector message{0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x0a, 0xff, 0xee, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0x00, 0x0a, 0xff, 0xee, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x11, 0x00, 0x0a, 0xff, 0xee, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22};

//    BlockVector key{0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01, 0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88};
    auto res = OMAC(64, message, 16*4, std::move(key));

    for(auto& item: res) {
        std::cout << (int)item << std::endl;
    }

    return 0;
}